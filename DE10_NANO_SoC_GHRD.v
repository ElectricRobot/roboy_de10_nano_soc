
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
//`define ENABLE_HPS
module DE10_NANO_SoC_GHRD(
///////// ADC /////////
      output             ADC_CONVST,
      output             ADC_SCK,
      output             ADC_SDI,
      input              ADC_SDO,

      ///////// ARDUINO /////////
      inout       [15:0] ARDUINO_IO,
      inout              ARDUINO_RESET_N,

      ///////// FPGA /////////
      input              FPGA_CLK1_50,
      input              FPGA_CLK2_50,
      input              FPGA_CLK3_50,

      ///////// GPIO /////////
      inout       [35:0] GPIO_0,
      inout       [35:0] GPIO_1,

      ///////// HDMI /////////
      inout              HDMI_I2C_SCL,
      inout              HDMI_I2C_SDA,
      inout              HDMI_I2S,
      inout              HDMI_LRCLK,
      inout              HDMI_MCLK,
      inout              HDMI_SCLK,
      output             HDMI_TX_CLK,
      output      [23:0] HDMI_TX_D,
      output             HDMI_TX_DE,
      output             HDMI_TX_HS,
      input              HDMI_TX_INT,
      output             HDMI_TX_VS,

`ifdef ENABLE_HPS
      ///////// HPS /////////
      inout              HPS_CONV_USB_N,
      output      [14:0] HPS_DDR3_ADDR,
      output      [2:0]  HPS_DDR3_BA,
      output             HPS_DDR3_CAS_N,
      output             HPS_DDR3_CKE,
      output             HPS_DDR3_CK_N,
      output             HPS_DDR3_CK_P,
      output             HPS_DDR3_CS_N,
      output      [3:0]  HPS_DDR3_DM,
      inout       [31:0] HPS_DDR3_DQ,
      inout       [3:0]  HPS_DDR3_DQS_N,
      inout       [3:0]  HPS_DDR3_DQS_P,
      output             HPS_DDR3_ODT,
      output             HPS_DDR3_RAS_N,
      output             HPS_DDR3_RESET_N,
      input              HPS_DDR3_RZQ,
      output             HPS_DDR3_WE_N,
      output             HPS_ENET_GTX_CLK,
      inout              HPS_ENET_INT_N,
      output             HPS_ENET_MDC,
      inout              HPS_ENET_MDIO,
      input              HPS_ENET_RX_CLK,
      input       [3:0]  HPS_ENET_RX_DATA,
      input              HPS_ENET_RX_DV,
      output      [3:0]  HPS_ENET_TX_DATA,
      output             HPS_ENET_TX_EN,
      inout              HPS_GSENSOR_INT,
      inout              HPS_I2C0_SCLK,
      inout              HPS_I2C0_SDAT,
      inout              HPS_I2C1_SCLK,
      inout              HPS_I2C1_SDAT,
      inout              HPS_KEY,
      inout              HPS_LED,
      inout              HPS_LTC_GPIO,
      output             HPS_SD_CLK,
      inout              HPS_SD_CMD,
      inout       [3:0]  HPS_SD_DATA,
      output             HPS_SPIM_CLK,
      input              HPS_SPIM_MISO,
      output             HPS_SPIM_MOSI,
      inout              HPS_SPIM_SS,
      input              HPS_UART_RX,
      output             HPS_UART_TX,
      input              HPS_USB_CLKOUT,
      inout       [7:0]  HPS_USB_DATA,
      input              HPS_USB_DIR,
      input              HPS_USB_NXT,
      output             HPS_USB_STP,
`endif /*ENABLE_HPS*/

      ///////// KEY /////////
      input       [1:0]  KEY,

      ///////// LED /////////
      output      [7:0]  LED,

      ///////// SW /////////
      input       [3:0]  SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire     [1: 0]     fpga_debounced_buttons;

//=======================================================
//  Structural coding
//=======================================================
soc_system soc(
	.clk_clk(FPGA_CLK1_50),
	.reset_reset_n(fpga_debounced_buttons[1]),
   .darkroom_0_conduit_end_mosi_o(GPIO_1[2]),           
	.darkroom_0_conduit_end_sck_o(GPIO_1[0]),            
	.darkroom_0_conduit_end_sensor_signals_i({GPIO_1[25:10],GPIO_0[25:10]}), 
	.darkroom_0_conduit_end_ss_n_o(GPIO_1[1]),         
	.darkroom_0_conduit_end_trigger_me(~KEY[0]) ,
	.darkroom_0_conduit_end_sync_o(sync) ,
	.darkroomootxdecoder_0_conduit_end_led(LED),
	.darkroomootxdecoder_0_conduit_end_sensor(GPIO_0[0]),
	.darkroomootxdecoder_0_conduit_end_uart_tx(GPIO_0[2]) 
); 

////// DarkRoom can also be instantiated individually
//DarkRoom #(32) darkroom(
//	.clock(FPGA_CLK1_50),
//	.reset_n(KEY[1]),
//	// those are the sensor signals
//	.sensor_signals_i({GPIO_1[25:10],GPIO_0[25:10]}),
//	// SPI
//	.sck_o(GPIO_1[0]), // clock
//	.ss_n_o(GPIO_1[1]), // slave select
//	.mosi_o(GPIO_1[2])	// mosi
//);
//
//// DarkRoom ootx decoder can also be instantiated individually
//DarkRoomOOTXdecoder ootx_decoder(
//	.clock(FPGA_CLK1_50),
//	.reset(~KEY[1]),
//	// uart tx port
//	.uart_tx(GPIO_0[2]),
//	.sensor(GPIO_0[0]), 
//	.led(LED)
//);

// Debounce logic to clean out glitches within 1ms
debounce debounce_inst(
             .clk(FPGA_CLK1_50),
             .reset_n(hps_fpga_reset_n),
             .data_in(KEY),
             .data_out(fpga_debounced_buttons)
         );
defparam debounce_inst.WIDTH = 2;
defparam debounce_inst.POLARITY = "LOW";
defparam debounce_inst.TIMEOUT = 50000;               // at 50Mhz this is a debounce time of 1ms
defparam debounce_inst.TIMEOUT_WIDTH = 16;            // ceil(log2(TIMEOUT))

//wire [31:0] sync;

//reg [7:0] counter;
//always @(posedge FPGA_CLK1_50, negedge KEY[1]) begin: LED_ANIMATION
//	if (KEY[1] == 0) begin 
//		counter <= 0;
//	end else begin
//		if(|sync==1'b1) 
//			counter <= counter+1;
//	end 
//end 
//assign LED = counter;

endmodule
